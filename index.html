<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>P2P File Share</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   åŸºæœ¬ãƒ‡ã‚¶ã‚¤ãƒ³ï¼šå…ƒã®P2P Chatã¨åŒã˜ãƒ†ã‚¤ã‚¹ãƒˆ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
body {
    margin: 0;
    min-height: 100vh;
    background: radial-gradient(circle at 10% 20%, #f8cdda 0, #1d2b64 60%, #141e30 100%);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    padding: 12px 10px 20px;
    box-sizing: border-box;
}

/* ã‚«ãƒ¼ãƒ‰å…±é€š */
.card {
    width: 100%;
    max-width: 460px;
    background: rgba(255,255,255,0.10);
    border-radius: 22px;
    box-shadow: 0 18px 40px rgba(0,0,0,0.45);
    backdrop-filter: blur(24px);
    border: 1px solid rgba(255,255,255,0.18);
    padding: 20px 18px 18px;
    animation: fadeIn 0.45s ease;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    margin: 10px auto;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px) scale(0.98); }
    to   { opacity: 1; transform: translateY(0) scale(1); }
}

/* ã‚¿ã‚¤ãƒˆãƒ«éƒ¨åˆ† */
.title-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-bottom: 8px;
}
.title-accent {
    width: 26px;
    height: 26px;
    border-radius: 999px;
    background: conic-gradient(from 200deg, #ff9a9e, #fad0c4, #fbc2eb, #a6c1ee, #ff9a9e);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 14px;
}
h2 {
    margin: 0;
    text-align: center;
    font-weight: 600;
    color: #f9fafb;
    letter-spacing: 0.03em;
}

/* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ãƒ™ãƒ« */
.status-pill {
    align-self: center;
    margin: 6px 0 10px;
    padding: 6px 12px;
    border-radius: 999px;
    font-size: 12px;
    color: #e5ecff;
    background: rgba(15,118,255,0.16);
    border: 1px solid rgba(144,202,249,0.4);
}

/* ãƒœã‚¿ãƒ³ */
button {
    width: 100%;
    padding: 11px;
    margin-top: 10px;
    border-radius: 14px;
    border: none;
    background: linear-gradient(135deg, #4f46e5, #22d3ee);
    color: white;
    font-size: 15px;
    cursor: pointer;
    transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
    box-shadow: 0 6px 14px rgba(15,23,42,0.45);
}
button:hover {
    filter: brightness(1.05);
    transform: translateY(-1px);
    box-shadow: 0 10px 20px rgba(15,23,42,0.6);
}
button:active {
    transform: translateY(0);
    box-shadow: 0 4px 10px rgba(15,23,42,0.5);
}
button:disabled {
    opacity: 0.5;
    cursor: default;
    box-shadow: none;
    transform: none;
}

/* ãƒ­ãƒ¼ãƒ«é¸æŠç”¨ãƒœã‚¿ãƒ³ */
.role-row {
    display: flex;
    gap: 8px;
    margin-top: 6px;
}
.role-btn {
    width: 100%;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.8);
    background: rgba(15,23,42,0.85);
    color: #e5e7eb;
    font-size: 13px;
    box-shadow: none;
}
.role-btn.selected {
    border: none;
    background: linear-gradient(135deg, #4f46e5, #22d3ee);
    color: #f9fafb;
    box-shadow: 0 6px 14px rgba(15,23,42,0.5);
}

/* ã‚µãƒ–ãƒœã‚¿ãƒ³ï¼ˆå°ã•ã„ãƒœã‚¿ãƒ³ï¼‰ */
.small-btn {
    margin-top: 6px;
    padding: 8px;
    width: auto;
    min-width: 72px;
    border-radius: 12px;
    font-size: 11px;
    background: rgba(15,23,42,0.75);
    box-shadow: none;
}
.small-btn:hover {
    background: rgba(15,23,42,0.9);
    box-shadow: none;
}

/* å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ  */
textarea, input {
    width: 100%;
    padding: 9px 10px;
    margin-top: 6px;
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.8);
    background: rgba(15,23,42,0.65);
    color: #e5e7eb;
    outline: none;
    font-size: 13px;
    box-sizing: border-box;
}
textarea::placeholder,
input::placeholder {
    color: rgba(148,163,184,0.9);
}

/* ãƒ©ãƒ™ãƒ«ãƒ†ã‚­ã‚¹ãƒˆ */
.label {
    font-size: 13px;
    color: #e5e7eb;
    margin-top: 10px;
}

/* æ¥ç¶šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
#mainStatus {
    text-align: center;
    color: #e5ecff;
    font-weight: 500;
    font-size: 13px;
    margin-bottom: 4px;
}

/* ã‚³ãƒ¼ãƒ‰è¡Œ */
.code-row {
    display: flex;
    gap: 6px;
    margin-top: 6px;
}
.code-row input {
    flex: 1;
    margin-top: 0;
}
.code-btns {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

/* ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ”ãƒ« */
.conn-pill {
    align-self: flex-start;
    margin-top: 8px;
    padding: 4px 10px;
    font-size: 11px;
    background: rgba(15,23,42,0.75);
    border: 1px solid rgba(148,163,184,0.7);
    display: inline-flex;
    align-items: center;
    gap: 6px;
}
.conn-dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #f97373;
}
.conn-dot.on {
    background: #4ade80;
}

/* ãƒ•ã‚¡ã‚¤ãƒ«è¡Œ */
.file-row {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-top: 6px;
}
#fileInput {
    flex: 1;
    padding: 6px 8px;
    font-size: 11px;
    background: rgba(15,23,42,0.65);
    border-radius: 12px;
    border: 1px solid rgba(148,163,184,0.8);
    color: #e5e7eb;
}

/* é€²æ—ãƒãƒ¼ */
.progress-box {
    margin-top: 10px;
}
.progress-label {
    font-size: 12px;
    color: #e5e7eb;
    margin-bottom: 4px;
}
.progress-wrap {
    width: 100%;
    height: 8px;
    border-radius: 999px;
    background: rgba(15,23,42,0.8);
    border: 1px solid rgba(148,163,184,0.4);
    overflow: hidden;
}
.progress-bar {
    height: 100%;
    width: 0%;
    border-radius: 999px;
    background: linear-gradient(90deg, #22c55e, #38bdf8, #a855f7);
    transition: width 0.12s linear;
}

/* ãƒ­ã‚° */
#log {
    margin-top: 10px;
    padding: 8px 10px;
    border-radius: 14px;
    background: rgba(15,23,42,0.75);
    border: 1px solid rgba(148,163,184,0.6);
    font-size: 11px;
    color: #e5e7eb;
    max-height: 180px;
    overflow-y: auto;
    white-space: pre-wrap;
}
.log-line {
    margin: 2px 0;
}

/* ãƒ•ãƒƒã‚¿ãƒ¼ */
.footer {
    margin-top: 8px;
    text-align: center;
    font-size: 11px;
    color: rgba(241,245,249,0.7);
    letter-spacing: 0.04em;
}

/* PCæ™‚ã ã‘ä¸­å¤®å¯„ã› */
@media (min-width: 768px) {
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 16px;
    }
}
</style>
</head>
<body>

<div class="card">
    <div class="title-row">
        <div class="title-accent">ğŸ“¦</div>
        <h2>P2P File Share</h2>
    </div>
    <div class="status-pill">ã‚µãƒ¼ãƒãƒ¼ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ãªã„ãƒ»ãƒ–ãƒ©ã‚¦ã‚¶åŒå£«ã§ç›´çµ</div>

    <div id="mainStatus">ãƒ­ãƒ¼ãƒ«ã‚’é¸æŠã—ã¦æ¥ç¶šã‚³ãƒ¼ãƒ‰ã‚’æ±ºã‚ã¦ãã ã•ã„ã€‚</div>

    <!-- 1. ãƒ­ãƒ¼ãƒ«é¸æŠ -->
    <div class="label">1. ãƒ­ãƒ¼ãƒ«é¸æŠ</div>
    <div class="role-row">
        <button id="hostBtn" class="role-btn">ãƒ›ã‚¹ãƒˆ</button>
        <button id="guestBtn" class="role-btn">ã‚²ã‚¹ãƒˆ</button>
    </div>

    <!-- 2. æ¥ç¶šã‚³ãƒ¼ãƒ‰ -->
    <div class="label">2. æ¥ç¶šã‚³ãƒ¼ãƒ‰ï¼ˆæ•°å­—ï¼‰</div>
    <div class="code-row">
        <input id="roomCodeInput" type="text" inputmode="numeric" pattern="[0-9]*"
               placeholder="6æ¡ãã‚‰ã„ã®æ•°å­—ã‚³ãƒ¼ãƒ‰ï¼ˆä¾‹: 493821ï¼‰">
        <div class="code-btns">
            <button id="genCodeBtn" class="small-btn">ç”Ÿæˆ</button>
            <button id="copyCodeBtn" class="small-btn">ã‚³ãƒ”ãƒ¼</button>
            <button id="pasteCodeBtn" class="small-btn">ãƒšãƒ¼ã‚¹ãƒˆ</button>
        </div>
    </div>

    <button id="connectBtn">ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã«æ¥ç¶š</button>

    <div class="conn-pill" id="connPill">
        <span class="conn-dot" id="connDot"></span>
        <span id="connText">æœªæ¥ç¶š</span>
    </div>

    <!-- 3. ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ -->
    <div class="label">3. ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ï¼ˆæœ€å¤§1GBç›®å®‰ï¼‰</div>
    <div class="file-row">
        <input type="file" id="fileInput">
        <button id="sendBtn" class="small-btn" disabled>é€ä¿¡</button>
    </div>
    <button id="cancelBtn" class="small-btn" disabled>é€ä¿¡ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>

    <div class="progress-box">
        <div class="progress-label" id="progressText">é€ä¿¡ / å—ä¿¡å¾…æ©Ÿä¸­</div>
        <div class="progress-wrap">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>

    <div id="log"></div>
</div>

<div class="footer">
    taiboku_passent all right reserved
</div>

<script>
/* ====== DOM ====== */
const hostBtn = document.getElementById("hostBtn");
const guestBtn = document.getElementById("guestBtn");
const roomCodeInput = document.getElementById("roomCodeInput");
const genCodeBtn = document.getElementById("genCodeBtn");
const copyCodeBtn = document.getElementById("copyCodeBtn");
const pasteCodeBtn = document.getElementById("pasteCodeBtn");
const connectBtn = document.getElementById("connectBtn");

const connPill = document.getElementById("connPill");
const connDot = document.getElementById("connDot");
const connText = document.getElementById("connText");

const mainStatus = document.getElementById("mainStatus");
const fileInput = document.getElementById("fileInput");
const sendBtn = document.getElementById("sendBtn");
const cancelBtn = document.getElementById("cancelBtn");

const progressBar = document.getElementById("progressBar");
const progressText = document.getElementById("progressText");
const logEl = document.getElementById("log");

/* ====== çŠ¶æ…‹ ====== */
let role = null;             // "host" | "guest"
let roomCode = "";
let joinedSignaling = false;
let pollTimer = null;

let pc = null;
let dataChannel = null;

let fileSending = false;
let fileReceiving = false;
let sendingAbort = false;

let incomingFileMeta = null;
let incomingChunks = [];
let incomingBytes = 0;

const MAX_FILE_SIZE = 1 * 1024 * 1024 * 1024; // 1GB

/* ====== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ====== */
function log(text) {
    const line = document.createElement("div");
    line.className = "log-line";
    const time = new Date().toLocaleTimeString("ja-JP", {
        hour12: false,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
    });
    line.textContent = `[${time}] ${text}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
}

function setConn(connected) {
    if (connected) {
        connDot.classList.add("on");
        connText.textContent = "ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°æ¥ç¶šä¸­";
    } else {
        connDot.classList.remove("on");
        connText.textContent = "æœªæ¥ç¶š";
    }
}

function setProgress(ratio, label) {
    const p = Math.max(0, Math.min(1, ratio || 0));
    progressBar.style.width = (p * 100) + "%";
    if (label !== undefined) progressText.textContent = label;
}

function humanSize(bytes) {
    if (bytes === 0) return "0 B";
    const units = ["B", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    const value = bytes / Math.pow(1024, i);
    return value.toFixed(value >= 10 ? 1 : 2) + " " + units[i];
}

/* ====== ãƒ­ãƒ¼ãƒ«é¸æŠ ====== */
hostBtn.addEventListener("click", () => {
    role = "host";
    hostBtn.classList.add("selected");
    guestBtn.classList.remove("selected");
    mainStatus.textContent = "ãƒ›ã‚¹ãƒˆã¨ã—ã¦éƒ¨å±‹ã‚’ä½œã‚Šã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚’æ±ºã‚ã¦ç›¸æ‰‹ã«æ•™ãˆã¦ãã ã•ã„ã€‚";
});

guestBtn.addEventListener("click", () => {
    role = "guest";
    guestBtn.classList.add("selected");
    hostBtn.classList.remove("selected");
    mainStatus.textContent = "ã‚²ã‚¹ãƒˆã¨ã—ã¦å‚åŠ ã—ã¾ã™ã€‚ãƒ›ã‚¹ãƒˆã‹ã‚‰ã‚‚ã‚‰ã£ãŸã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
});

/* ====== ã‚³ãƒ¼ãƒ‰ç”Ÿæˆãƒ»ã‚³ãƒ”ãƒ¼ãƒ»ãƒšãƒ¼ã‚¹ãƒˆ ====== */
genCodeBtn.addEventListener("click", () => {
    const code = Math.floor(Math.random() * 900000) + 100000; // 6æ¡
    roomCodeInput.value = String(code);
});

copyCodeBtn.addEventListener("click", () => {
    const text = roomCodeInput.value.trim();
    if (!text) {
        alert("ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“");
        return;
    }
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
            .then(() => alert("ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ"))
            .catch(() => alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ"));
    } else {
        roomCodeInput.select();
        document.execCommand("copy");
        alert("ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ˆå¤ã„APIï¼‰");
    }
});

pasteCodeBtn.addEventListener("click", async () => {
    if (!(navigator.clipboard && navigator.clipboard.readText)) {
        alert("ã“ã®ç’°å¢ƒã§ã¯ãƒšãƒ¼ã‚¹ãƒˆAPIãŒä½¿ãˆã¾ã›ã‚“ã€‚é•·æŠ¼ã—ã§è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚");
        return;
    }
    try {
        const text = await navigator.clipboard.readText();
        roomCodeInput.value = text;
    } catch {
        alert("ãƒšãƒ¼ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ");
    }
});

/* ====== ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°APIï¼ˆçŸ­ãƒãƒ¼ãƒªãƒ³ã‚°ï¼‰ ====== */
async function joinSignaling() {
    const res = await fetch("/api/signaling", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            action: "join",
            roomCode,
            role,
        }),
    });
    if (!res.ok) throw new Error("join failed");
}

async function sendSignal(payload) {
    if (!joinedSignaling) return;
    try {
        await fetch("/api/signaling", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                action: "send",
                roomCode,
                role,
                payload,
            }),
        });
    } catch (e) {
        console.error("sendSignal error:", e);
        log("ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°é€ä¿¡ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
    }
}

async function pollSignals() {
    if (!joinedSignaling || !roomCode || !role) return;
    try {
        const res = await fetch("/api/signaling", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                action: "recv",
                roomCode,
                role,
            }),
        });
        if (!res.ok) return;
        const data = await res.json();
        const messages = data.messages || [];
        for (const msg of messages) {
            if (msg && msg.payload) {
                await handleSignal(msg.payload);
            }
        }
    } catch (e) {
        console.error("poll error:", e);
    }
}

function startPolling() {
    if (pollTimer) return;
    pollSignals();
    pollTimer = setInterval(pollSignals, 1000);
}

function stopPolling() {
    if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
    }
}

async function leaveSignaling() {
    if (!joinedSignaling) return;
    try {
        await fetch("/api/signaling", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                action: "leave",
                roomCode,
                role,
            }),
        });
    } catch (e) {
        console.error("leave error:", e);
    }
    joinedSignaling = false;
    setConn(false);
    stopPolling();
}

window.addEventListener("beforeunload", () => {
    leaveSignaling();
});

/* ====== æ¥ç¶šãƒœã‚¿ãƒ³ ====== */
connectBtn.addEventListener("click", async () => {
    if (joinedSignaling) {
        log("ã™ã§ã«ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã«å‚åŠ æ¸ˆã¿ã§ã™ã€‚");
        return;
    }

    roomCode = roomCodeInput.value.trim();
    if (!roomCode) {
        alert("æ¥ç¶šã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
        return;
    }
    if (!role) {
        alert("ãƒ›ã‚¹ãƒˆã‹ã‚²ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
        return;
    }

    try {
        await joinSignaling();
        joinedSignaling = true;
        setConn(true);
        log(`ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã«å‚åŠ ã—ã¾ã—ãŸã€‚éƒ¨å±‹ã‚³ãƒ¼ãƒ‰: ${roomCode}`);
        mainStatus.textContent = "ç›¸æ‰‹ãŒåŒã˜ã‚³ãƒ¼ãƒ‰ã§æ¥ç¶šã™ã‚‹ã¨P2Pæ¥ç¶šã‚’é–‹å§‹ã—ã¾ã™ã€‚";
        startPolling();
        initPeerConnectionIfNeeded();
    } catch (e) {
        console.error(e);
        log("ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        mainStatus.textContent = "ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
    }
});

/* ====== WebRTC ãƒ”ã‚¢æ¥ç¶š ====== */
const rtcConfig = {
    iceServers: [
        { urls: "stun:stun.l.google.com:19302" }
    ],
};

function initPeerConnectionIfNeeded() {
    if (pc) return;
    pc = new RTCPeerConnection(rtcConfig);

    pc.onicecandidate = (event) => {
        if (event.candidate) {
            sendSignal({
                type: "ice",
                candidate: event.candidate,
            });
        }
    };

    pc.onconnectionstatechange = () => {
        log(`PeerConnection state: ${pc.connectionState}`);
        if (["disconnected", "failed", "closed"].includes(pc.connectionState)) {
            cleanupConnection();
            mainStatus.textContent = "P2Pæ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚";
        }
    };

    if (role === "guest") {
        pc.ondatachannel = (event) => {
            dataChannel = event.channel;
            setupDataChannel();
        };
    }
}

async function handleSignal(payload) {
    switch (payload.type) {
        case "ready":
            log("ç›¸æ‰‹ãŒå…¥å®¤ã—ã¾ã—ãŸã€‚WebRTC æ¥ç¶šã‚’é–‹å§‹ã—ã¾ã™ã€‚");
            await onReady();
            break;
        case "offer":
            if (role === "guest") {
                await onOffer(payload.sdp);
            }
            break;
        case "answer":
            if (role === "host") {
                await onAnswer(payload.sdp);
            }
            break;
        case "ice":
            if (pc && payload.candidate) {
                try {
                    await pc.addIceCandidate(payload.candidate);
                } catch (e) {
                    console.error("Error adding ICE candidate:", e);
                }
            }
            break;
        case "peer-left":
            log("ç›¸æ‰‹ãŒã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã‹ã‚‰é›¢è„±ã—ã¾ã—ãŸã€‚");
            cleanupConnection();
            break;
        case "cancel":
            log("ç›¸æ‰‹ãŒé€ä¿¡ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚");
            break;
    }
}

async function onReady() {
    initPeerConnectionIfNeeded();

    if (role === "host" && !dataChannel) {
        dataChannel = pc.createDataChannel("file");
        setupDataChannel();

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        await sendSignal({
            type: "offer",
            sdp: pc.localDescription,
        });

        log("SDP offer ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚");
    } else if (role === "guest") {
        log("ãƒ›ã‚¹ãƒˆã‹ã‚‰ã® offer ã‚’å¾…æ©Ÿä¸­ã§ã™ã€‚");
    }
}

async function onOffer(sdp) {
    initPeerConnectionIfNeeded();
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    await sendSignal({
        type: "answer",
        sdp: pc.localDescription,
    });

    log("SDP answer ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚");
}

async function onAnswer(sdp) {
    if (!pc) return;
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    log("answer ã‚’å—ä¿¡ã—ã€æ¥ç¶šå‡¦ç†ä¸­ã§ã™ã€‚");
}

function setupDataChannel() {
    if (!dataChannel) return;

    dataChannel.binaryType = "arraybuffer";

    dataChannel.onopen = () => {
        log("DataChannel open: ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ãŒå¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚");
        mainStatus.textContent = "P2Pæ¥ç¶šå®Œäº†ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§é€ä¿¡ã§ãã¾ã™ã€‚";
        sendBtn.disabled = false;
    };

    dataChannel.onclose = () => {
        log("DataChannel closed");
        sendBtn.disabled = true;
        cancelBtn.disabled = true;
    };

    dataChannel.onerror = (e) => {
        console.error("DataChannel error:", e);
        log("DataChannel ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
    };

    dataChannel.onmessage = (event) => {
        const data = event.data;

        if (typeof data === "string") {
            try {
                const obj = JSON.parse(data);
                if (obj && obj.type === "file-meta") {
                    incomingFileMeta = obj;
                    incomingChunks = [];
                    incomingBytes = 0;
                    fileReceiving = true;
                    log(`ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±å—ä¿¡: ${obj.name} (${humanSize(obj.size)}). å—ä¿¡é–‹å§‹ã€‚`);
                    setProgress(0, "å—ä¿¡ä¸­: 0%");
                    return;
                }
            } catch (e) {
                // JSON ã˜ã‚ƒãªã‘ã‚Œã°EOFåˆ¤å®š
                if (data === "EOF") {
                    if (fileReceiving && incomingFileMeta) {
                        finalizeReceive();
                    }
                    return;
                }
            }
        } else if (data instanceof ArrayBuffer) {
            if (!fileReceiving || !incomingFileMeta) {
                log("è­¦å‘Š: ãƒ¡ã‚¿æƒ…å ±ãªã—ã§ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚");
                return;
            }
            incomingChunks.push(new Uint8Array(data));
            incomingBytes += data.byteLength;

            const ratio = incomingFileMeta.size
                ? incomingBytes / incomingFileMeta.size
                : 0;
            const percent = (ratio * 100).toFixed(1);
            setProgress(ratio, `å—ä¿¡ä¸­: ${percent}% (${humanSize(incomingBytes)})`);
        }
    };
}

function finalizeReceive() {
    fileReceiving = false;
    const meta = incomingFileMeta;
    const totalBytes = incomingBytes;

    log(`å—ä¿¡å®Œäº†: ${meta.name} (${humanSize(totalBytes)}). ãƒ–ãƒ©ã‚¦ã‚¶ã§ä¿å­˜ã—ã¾ã™ã€‚`);

    const blob = new Blob(incomingChunks);
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = meta.name || "download.bin";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    setProgress(1, "å—ä¿¡å®Œäº†");
    incomingFileMeta = null;
    incomingChunks = [];
    incomingBytes = 0;
}

function cleanupConnection() {
    sendBtn.disabled = true;
    cancelBtn.disabled = true;
    fileSending = false;
    fileReceiving = false;

    if (dataChannel) {
        try { dataChannel.close(); } catch {}
        dataChannel = null;
    }
    if (pc) {
        try { pc.close(); } catch {}
        pc = null;
    }
    setProgress(0, "é€ä¿¡ / å—ä¿¡å¾…æ©Ÿä¸­");
}

/* ====== ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ ====== */
sendBtn.addEventListener("click", async () => {
    if (!dataChannel || dataChannel.readyState !== "open") {
        alert("DataChannel ãŒé–‹ã„ã¦ã„ã¾ã›ã‚“ã€‚æ¥ç¶šçŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
        return;
    }

    const file = fileInput.files[0];
    if (!file) {
        alert("é€ä¿¡ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
        return;
    }

    if (file.size > MAX_FILE_SIZE) {
        alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ã€‚æœ€å¤§ ${humanSize(MAX_FILE_SIZE)} ã¾ã§ã«ã—ã¦ãã ã•ã„ã€‚`);
        return;
    }

    fileSending = true;
    sendingAbort = false;
    sendBtn.disabled = true;
    cancelBtn.disabled = false;

    log(`é€ä¿¡é–‹å§‹: ${file.name} (${humanSize(file.size)}). ãƒãƒ£ãƒ³ã‚¯åˆ†å‰²ã—ã¦é€ä¿¡ã—ã¾ã™ã€‚`);
    setProgress(0, "é€ä¿¡ä¸­: 0%");

    try {
        await sendFileInChunks(file);
        if (!sendingAbort) {
            log("é€ä¿¡å®Œäº†ã—ã¾ã—ãŸã€‚");
            setProgress(1, "é€ä¿¡å®Œäº†");
        } else {
            log("é€ä¿¡ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚");
        }
    } catch (e) {
        console.error(e);
        log("é€ä¿¡ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
    } finally {
        fileSending = false;
        cancelBtn.disabled = true;
        if (dataChannel && dataChannel.readyState === "open") {
            sendBtn.disabled = false;
        }
    }
});

cancelBtn.addEventListener("click", () => {
    if (!fileSending) return;
    sendingAbort = true;
    cancelBtn.disabled = true;
    if (dataChannel && dataChannel.readyState === "open") {
        try {
            dataChannel.send(JSON.stringify({ type: "cancel" }));
        } catch {}
    }
    log("é€ä¿¡ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¦æ±‚ã‚’å‡ºã—ã¾ã—ãŸã€‚");
});

async function sendFileInChunks(file) {
    const chunkSize = 64 * 1024; // 64KB
    let offset = 0;

    // ãƒ¡ã‚¿æƒ…å ±
    dataChannel.send(JSON.stringify({
        type: "file-meta",
        name: file.name,
        size: file.size,
        lastModified: file.lastModified,
    }));

    while (offset < file.size) {
        if (sendingAbort) break;

        const slice = file.slice(offset, offset + chunkSize);
        const buffer = await slice.arrayBuffer();

        dataChannel.send(buffer);
        offset += chunkSize;

        const ratio = offset / file.size;
        const percent = (ratio * 100).toFixed(1);
        setProgress(ratio, `é€ä¿¡ä¸­: ${percent}% (${humanSize(offset)})`);

        if (dataChannel.bufferedAmount > 16 * 1024 * 1024) {
            await waitForBufferedAmountLow(dataChannel, 8 * 1024 * 1024);
        }
    }

    if (!sendingAbort) {
        dataChannel.send("EOF");
    }
}

function waitForBufferedAmountLow(dc, threshold) {
    return new Promise((resolve) => {
        function check() {
            if (dc.bufferedAmount <= threshold) {
                dc.removeEventListener("bufferedamountlow", onLow);
                resolve();
            }
        }
        function onLow() {
            check();
        }

        dc.addEventListener("bufferedamountlow", onLow);
        check();

        setTimeout(() => {
            dc.removeEventListener("bufferedamountlow", onLow);
            resolve();
        }, 3000);
    });
}

/* åˆæœŸçŠ¶æ…‹ */
setConn(false);
setProgress(0, "é€ä¿¡ / å—ä¿¡å¾…æ©Ÿä¸­");
</script>

</body>
</html>
